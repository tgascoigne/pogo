package pogo

import (
	"bytes"
	"flag"
	"fmt"
	"html/template"
	"io/ioutil"
	"reflect"
	"strings"

	"golang.org/x/tools/imports"
)

var generateVisitor = flag.Bool("generate-visitor", false, "")

var VisitorTemplate = visitorTemplate{
	Productions: make(map[string]reflect.Type),
}

type visitorTemplate struct {
	Productions     map[string]reflect.Type
	ProductionOrder []string
	EmbedInterface  string
}

func packageShortName(path string) string {
	parts := strings.Split(path, "/")
	return parts[len(parts)-1]
}

var prodTemplate = template.Must(template.New("").Parse(`// all{{.Prod}}s accepts all {{.Prod}} productions in the given list of items
func all{{.Prod}}s(v {{.PkgName}}Visitor, items []pogo.Parsed) []{{.TypeName}} {
	result := make([]{{.TypeName}}, 0)
	for _, p := range items {
		if _, ok := is{{.Prod}}(p); ok {
			result = append(result, accept{{.Prod}}(v, p))
		}
	}
	return result
}

// accept{{.Prod}} visits p as a {{.Prod}} production
func accept{{.Prod}}(v {{.PkgName}}Visitor, p pogo.Parsed) {{.TypeName}} {
	if *parseDebug {
		fmt.Printf("accept{{.Prod}}: %%v\n", p)
	}

	if prod, ok := is{{.Prod}}(p); ok {
		return v.visit{{.Prod}}(v, []pogo.Parsed(prod.Children))
	}

	panic("expected {{.Prod}}")
}

// build{{.Prod}}Visitor constructs a {{.PkgName}}Visitor which overrides visit{{.Prod}} on the base visitor
func build{{.Prod}}Visitor(base {{.PkgName}}Visitor, fn func(delegate {{.PkgName}}Visitor, items []pogo.Parsed) {{.TypeName}}) {{.PkgName}}Visitor {
	return &{{.PkgName}}LambdaVisitor{
		base: base,
		visit{{.Prod}}Func: fn,
{{if .EmbedInterface}}{{.EmbedInterface}}: base.getEmbedded(),{{end}}
	}
}

func (v *{{.PkgName}}LambdaVisitor) visit{{.Prod}}(delegate {{.PkgName}}Visitor, items []pogo.Parsed) {{.TypeName}} {
	if v.visit{{.Prod}}Func != nil {
		return v.visit{{.Prod}}Func(delegate, items)
	}

	return v.base.visit{{.Prod}}(delegate, items)
}
`))

var untypedProdTemplate = template.Must(template.New("").Parse(`// all{{.Prod}}s accepts all {{.Prod}} productions in the given list of items
func all{{.Prod}}s(v {{.PkgName}}Visitor, items []pogo.Parsed) {
	for _, p := range items {
		if _, ok := is{{.Prod}}(p); ok {
			accept{{.Prod}}(v, p)
		}
	}
}

// accept{{.Prod}} visits p as a {{.Prod}} production
func accept{{.Prod}}(v {{.PkgName}}Visitor, p pogo.Parsed){
	if *parseDebug {
		fmt.Printf("accept{{.Prod}}: %%v\n", p)
	}

	if prod, ok := is{{.Prod}}(p); ok {
		v.visit{{.Prod}}(v, []pogo.Parsed(prod.Children))
		return
	}

	panic("expected {{.Prod}}")
}

// build{{.Prod}}Visitor constructs a {{.PkgName}}Visitor which overrides visit{{.Prod}} on the base visitor
func build{{.Prod}}Visitor(base {{.PkgName}}Visitor, fn func(delegate {{.PkgName}}Visitor, items []pogo.Parsed)) {{.PkgName}}Visitor {
	return &{{.PkgName}}LambdaVisitor{
		base: base,
		visit{{.Prod}}Func: fn,
{{if .EmbedInterface}}{{.EmbedInterface}}: base.getEmbedded(),{{end}}
	}
}

func (v *{{.PkgName}}LambdaVisitor) visit{{.Prod}}(delegate {{.PkgName}}Visitor, items []pogo.Parsed) {
	if v.visit{{.Prod}}Func != nil {
		v.visit{{.Prod}}Func(delegate, items)
		return
	}

	v.base.visit{{.Prod}}(delegate, items)
}

`))

var commonProdTemplate = template.Must(template.New("").Parse(`// is{{.Prod}} determines if p is a {{.Prod}} production
func is{{.Prod}}(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "{{.Prod}}" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// all{{.Prod}}Children finds all {{.Prod}} productions in the given list of items, and returns their children as one list
func all{{.Prod}}Children(v {{.PkgName}}Visitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := is{{.Prod}}(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

`))

var footerTemplate = template.Must(template.New("").Parse(`// acceptItem interprets p as a pogo.Item
func acceptItem(v {{.}}Visitor, p pogo.Parsed) pogo.Item {
	if item, ok := p.(pogo.Item); ok {
		return item
	}

	panic("expected Item")
}
`))

var lambdaVisitorFuncTemplate = template.Must(template.New("").Parse(``))

func (v *visitorTemplate) Generate(ident, pkgName, path string) string {
	var visitorIface, lambdaStruct, prodFuncs, acceptFunc, whole bytes.Buffer
	fmt.Fprintf(&visitorIface, "// Code generated by pogo DO NOT EDIT\n")
	fmt.Fprintf(&visitorIface, "package %v\n\n", pkgName)
	fmt.Fprintf(&visitorIface, "var parseDebug = flag.Bool(\"parse-debug\", false, \"turn on parser debugging\")\n")
	fmt.Fprintf(&visitorIface, "type %vVisitor interface{\n", ident)
	if v.EmbedInterface != "" {
		fmt.Fprintf(&visitorIface, "%v\n", v.EmbedInterface)
	}
	fmt.Fprintf(&lambdaStruct, "type %vLambdaVisitor struct{\n", ident)
	if v.EmbedInterface != "" {
		fmt.Fprintf(&lambdaStruct, "%v\n", v.EmbedInterface)
	}
	fmt.Fprintf(&lambdaStruct, "base %vVisitor\n", ident)

	fmt.Fprintf(&acceptFunc, "// accept interprets p as a production and accepts it\n")
	fmt.Fprintf(&acceptFunc, "func accept(v %vVisitor, p pogo.Parsed) interface{} {\n", ident)
	fmt.Fprintf(&acceptFunc, "prod := p.(pogo.Production)\n")
	fmt.Fprintf(&acceptFunc, "switch prod.Ident {\n")

	for _, prod := range v.ProductionOrder {
		typ := v.Productions[prod]
		var typeName string
		if typ != nil {
			typeName = fmt.Sprintf("%s", typ)
			typePackageName := packageShortName(typ.PkgPath())
			if typePackageName == pkgName {
				typeName = typ.Name()
			}
		}

		tmplData := struct {
			Prod           string
			TypeName       string
			PkgName        string
			EmbedInterface string
		}{
			Prod:           prod,
			TypeName:       typeName,
			PkgName:        ident,
			EmbedInterface: v.EmbedInterface,
		}

		if typ != nil {
			fmt.Fprintf(&visitorIface, "visit%v(delegate %vVisitor, items []pogo.Parsed) %v\n", prod, ident, typeName)
			fmt.Fprintf(&lambdaStruct, "visit%vFunc func(%vVisitor, []pogo.Parsed) %v\n", prod, ident, typeName)
			prodTemplate.Execute(&prodFuncs, tmplData)

			fmt.Fprintf(&acceptFunc, "case \"%v\":\n", prod)
			fmt.Fprintf(&acceptFunc, "return accept%v(v, p)\n", prod)
		} else {
			fmt.Fprintf(&visitorIface, "visit%v(delegate %vVisitor, items []pogo.Parsed)\n", prod, ident)
			fmt.Fprintf(&lambdaStruct, "visit%vFunc func(%vVisitor, []pogo.Parsed)\n", prod, ident)

			untypedProdTemplate.Execute(&prodFuncs, tmplData)

			fmt.Fprintf(&acceptFunc, "case \"%v\":\n", prod)
			fmt.Fprintf(&acceptFunc, "accept%v(v, p)\n", prod)
			fmt.Fprintf(&acceptFunc, "return nil\n")
		}

		commonProdTemplate.Execute(&prodFuncs, tmplData)
		lambdaVisitorFuncTemplate.Execute(&prodFuncs, tmplData)
	}
	fmt.Fprintf(&visitorIface, "}\n\n")
	fmt.Fprintf(&lambdaStruct, "}\n")

	fmt.Fprintf(&acceptFunc, "default:\n")
	fmt.Fprintf(&acceptFunc, "panic(\"unknown production\")\n")
	fmt.Fprintf(&acceptFunc, "}\n")
	fmt.Fprintf(&acceptFunc, "}\n")

	fmt.Fprintf(&whole, visitorIface.String())
	fmt.Fprintf(&whole, lambdaStruct.String())
	fmt.Fprintf(&whole, prodFuncs.String())
	fmt.Fprintf(&whole, acceptFunc.String())
	footerTemplate.Execute(&whole, ident)

	srcName := ident + ".po.go"
	src, err := imports.Process(srcName, whole.Bytes(), nil)
	if err != nil {
		panic(err)
	}

	ioutil.WriteFile(path+"/"+srcName, src, 0744)

	return string(src)
}
