// Code generated by pogo DO NOT EDIT
package json

import (
	"flag"
	"fmt"

	"github.com/tgascoigne/pogo"
)

var parseDebug = flag.Bool("parse-debug", false, "turn on parser debugging")

type jsonVisitor interface {
	visitIntLiteral(delegate jsonVisitor, items []pogo.Parsed) int
	visitStringLiteral(delegate jsonVisitor, items []pogo.Parsed) string
	visitBooleanLiteral(delegate jsonVisitor, items []pogo.Parsed) bool
	visitList(delegate jsonVisitor, items []pogo.Parsed) []interface{}
	visitDict(delegate jsonVisitor, items []pogo.Parsed) map[interface{}]interface{}
	visitField(delegate jsonVisitor, items []pogo.Parsed) dictField
	visitValue(delegate jsonVisitor, items []pogo.Parsed) jsonValue
}

type jsonLambdaVisitor struct {
	base                    jsonVisitor
	visitIntLiteralFunc     func(jsonVisitor, []pogo.Parsed) int
	visitStringLiteralFunc  func(jsonVisitor, []pogo.Parsed) string
	visitBooleanLiteralFunc func(jsonVisitor, []pogo.Parsed) bool
	visitListFunc           func(jsonVisitor, []pogo.Parsed) []interface{}
	visitDictFunc           func(jsonVisitor, []pogo.Parsed) map[interface{}]interface{}
	visitFieldFunc          func(jsonVisitor, []pogo.Parsed) dictField
	visitValueFunc          func(jsonVisitor, []pogo.Parsed) jsonValue
}

// allIntLiterals accepts all IntLiteral productions in the given list of items
func allIntLiterals(v jsonVisitor, items []pogo.Parsed) []int {
	result := make([]int, 0)
	for _, p := range items {
		if _, ok := isIntLiteral(p); ok {
			result = append(result, acceptIntLiteral(v, p))
		}
	}
	return result
}

// acceptIntLiteral visits p as a IntLiteral production
func acceptIntLiteral(v jsonVisitor, p pogo.Parsed) int {
	if *parseDebug {
		fmt.Printf("acceptIntLiteral: %v\n", p)
	}

	if prod, ok := isIntLiteral(p); ok {
		return v.visitIntLiteral(v, []pogo.Parsed(prod.Children))
	}

	panic("expected IntLiteral")
}

// buildIntLiteralVisitor constructs a jsonVisitor which overrides visitIntLiteral on the base visitor
func buildIntLiteralVisitor(base jsonVisitor, fn func(delegate jsonVisitor, items []pogo.Parsed) int) jsonVisitor {
	return &jsonLambdaVisitor{
		base:                base,
		visitIntLiteralFunc: fn,
	}
}

func (v *jsonLambdaVisitor) visitIntLiteral(delegate jsonVisitor, items []pogo.Parsed) int {
	if v.visitIntLiteralFunc != nil {
		return v.visitIntLiteralFunc(delegate, items)
	}

	return v.base.visitIntLiteral(delegate, items)
}

// isIntLiteral determines if p is a IntLiteral production
func isIntLiteral(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "IntLiteral" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// allIntLiteralChildren finds all IntLiteral productions in the given list of items, and returns their children as one list
func allIntLiteralChildren(v jsonVisitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := isIntLiteral(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

// allStringLiterals accepts all StringLiteral productions in the given list of items
func allStringLiterals(v jsonVisitor, items []pogo.Parsed) []string {
	result := make([]string, 0)
	for _, p := range items {
		if _, ok := isStringLiteral(p); ok {
			result = append(result, acceptStringLiteral(v, p))
		}
	}
	return result
}

// acceptStringLiteral visits p as a StringLiteral production
func acceptStringLiteral(v jsonVisitor, p pogo.Parsed) string {
	if *parseDebug {
		fmt.Printf("acceptStringLiteral: %v\n", p)
	}

	if prod, ok := isStringLiteral(p); ok {
		return v.visitStringLiteral(v, []pogo.Parsed(prod.Children))
	}

	panic("expected StringLiteral")
}

// buildStringLiteralVisitor constructs a jsonVisitor which overrides visitStringLiteral on the base visitor
func buildStringLiteralVisitor(base jsonVisitor, fn func(delegate jsonVisitor, items []pogo.Parsed) string) jsonVisitor {
	return &jsonLambdaVisitor{
		base: base,
		visitStringLiteralFunc: fn,
	}
}

func (v *jsonLambdaVisitor) visitStringLiteral(delegate jsonVisitor, items []pogo.Parsed) string {
	if v.visitStringLiteralFunc != nil {
		return v.visitStringLiteralFunc(delegate, items)
	}

	return v.base.visitStringLiteral(delegate, items)
}

// isStringLiteral determines if p is a StringLiteral production
func isStringLiteral(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "StringLiteral" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// allStringLiteralChildren finds all StringLiteral productions in the given list of items, and returns their children as one list
func allStringLiteralChildren(v jsonVisitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := isStringLiteral(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

// allBooleanLiterals accepts all BooleanLiteral productions in the given list of items
func allBooleanLiterals(v jsonVisitor, items []pogo.Parsed) []bool {
	result := make([]bool, 0)
	for _, p := range items {
		if _, ok := isBooleanLiteral(p); ok {
			result = append(result, acceptBooleanLiteral(v, p))
		}
	}
	return result
}

// acceptBooleanLiteral visits p as a BooleanLiteral production
func acceptBooleanLiteral(v jsonVisitor, p pogo.Parsed) bool {
	if *parseDebug {
		fmt.Printf("acceptBooleanLiteral: %v\n", p)
	}

	if prod, ok := isBooleanLiteral(p); ok {
		return v.visitBooleanLiteral(v, []pogo.Parsed(prod.Children))
	}

	panic("expected BooleanLiteral")
}

// buildBooleanLiteralVisitor constructs a jsonVisitor which overrides visitBooleanLiteral on the base visitor
func buildBooleanLiteralVisitor(base jsonVisitor, fn func(delegate jsonVisitor, items []pogo.Parsed) bool) jsonVisitor {
	return &jsonLambdaVisitor{
		base: base,
		visitBooleanLiteralFunc: fn,
	}
}

func (v *jsonLambdaVisitor) visitBooleanLiteral(delegate jsonVisitor, items []pogo.Parsed) bool {
	if v.visitBooleanLiteralFunc != nil {
		return v.visitBooleanLiteralFunc(delegate, items)
	}

	return v.base.visitBooleanLiteral(delegate, items)
}

// isBooleanLiteral determines if p is a BooleanLiteral production
func isBooleanLiteral(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "BooleanLiteral" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// allBooleanLiteralChildren finds all BooleanLiteral productions in the given list of items, and returns their children as one list
func allBooleanLiteralChildren(v jsonVisitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := isBooleanLiteral(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

// allLists accepts all List productions in the given list of items
func allLists(v jsonVisitor, items []pogo.Parsed) [][]interface{} {
	result := make([][]interface{}, 0)
	for _, p := range items {
		if _, ok := isList(p); ok {
			result = append(result, acceptList(v, p))
		}
	}
	return result
}

// acceptList visits p as a List production
func acceptList(v jsonVisitor, p pogo.Parsed) []interface{} {
	if *parseDebug {
		fmt.Printf("acceptList: %v\n", p)
	}

	if prod, ok := isList(p); ok {
		return v.visitList(v, []pogo.Parsed(prod.Children))
	}

	panic("expected List")
}

// buildListVisitor constructs a jsonVisitor which overrides visitList on the base visitor
func buildListVisitor(base jsonVisitor, fn func(delegate jsonVisitor, items []pogo.Parsed) []interface{}) jsonVisitor {
	return &jsonLambdaVisitor{
		base:          base,
		visitListFunc: fn,
	}
}

func (v *jsonLambdaVisitor) visitList(delegate jsonVisitor, items []pogo.Parsed) []interface{} {
	if v.visitListFunc != nil {
		return v.visitListFunc(delegate, items)
	}

	return v.base.visitList(delegate, items)
}

// isList determines if p is a List production
func isList(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "List" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// allListChildren finds all List productions in the given list of items, and returns their children as one list
func allListChildren(v jsonVisitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := isList(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

// allDicts accepts all Dict productions in the given list of items
func allDicts(v jsonVisitor, items []pogo.Parsed) []map[interface{}]interface{} {
	result := make([]map[interface{}]interface{}, 0)
	for _, p := range items {
		if _, ok := isDict(p); ok {
			result = append(result, acceptDict(v, p))
		}
	}
	return result
}

// acceptDict visits p as a Dict production
func acceptDict(v jsonVisitor, p pogo.Parsed) map[interface{}]interface{} {
	if *parseDebug {
		fmt.Printf("acceptDict: %v\n", p)
	}

	if prod, ok := isDict(p); ok {
		return v.visitDict(v, []pogo.Parsed(prod.Children))
	}

	panic("expected Dict")
}

// buildDictVisitor constructs a jsonVisitor which overrides visitDict on the base visitor
func buildDictVisitor(base jsonVisitor, fn func(delegate jsonVisitor, items []pogo.Parsed) map[interface{}]interface{}) jsonVisitor {
	return &jsonLambdaVisitor{
		base:          base,
		visitDictFunc: fn,
	}
}

func (v *jsonLambdaVisitor) visitDict(delegate jsonVisitor, items []pogo.Parsed) map[interface{}]interface{} {
	if v.visitDictFunc != nil {
		return v.visitDictFunc(delegate, items)
	}

	return v.base.visitDict(delegate, items)
}

// isDict determines if p is a Dict production
func isDict(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "Dict" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// allDictChildren finds all Dict productions in the given list of items, and returns their children as one list
func allDictChildren(v jsonVisitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := isDict(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

// allFields accepts all Field productions in the given list of items
func allFields(v jsonVisitor, items []pogo.Parsed) []dictField {
	result := make([]dictField, 0)
	for _, p := range items {
		if _, ok := isField(p); ok {
			result = append(result, acceptField(v, p))
		}
	}
	return result
}

// acceptField visits p as a Field production
func acceptField(v jsonVisitor, p pogo.Parsed) dictField {
	if *parseDebug {
		fmt.Printf("acceptField: %v\n", p)
	}

	if prod, ok := isField(p); ok {
		return v.visitField(v, []pogo.Parsed(prod.Children))
	}

	panic("expected Field")
}

// buildFieldVisitor constructs a jsonVisitor which overrides visitField on the base visitor
func buildFieldVisitor(base jsonVisitor, fn func(delegate jsonVisitor, items []pogo.Parsed) dictField) jsonVisitor {
	return &jsonLambdaVisitor{
		base:           base,
		visitFieldFunc: fn,
	}
}

func (v *jsonLambdaVisitor) visitField(delegate jsonVisitor, items []pogo.Parsed) dictField {
	if v.visitFieldFunc != nil {
		return v.visitFieldFunc(delegate, items)
	}

	return v.base.visitField(delegate, items)
}

// isField determines if p is a Field production
func isField(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "Field" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// allFieldChildren finds all Field productions in the given list of items, and returns their children as one list
func allFieldChildren(v jsonVisitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := isField(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

// allValues accepts all Value productions in the given list of items
func allValues(v jsonVisitor, items []pogo.Parsed) []jsonValue {
	result := make([]jsonValue, 0)
	for _, p := range items {
		if _, ok := isValue(p); ok {
			result = append(result, acceptValue(v, p))
		}
	}
	return result
}

// acceptValue visits p as a Value production
func acceptValue(v jsonVisitor, p pogo.Parsed) jsonValue {
	if *parseDebug {
		fmt.Printf("acceptValue: %v\n", p)
	}

	if prod, ok := isValue(p); ok {
		return v.visitValue(v, []pogo.Parsed(prod.Children))
	}

	panic("expected Value")
}

// buildValueVisitor constructs a jsonVisitor which overrides visitValue on the base visitor
func buildValueVisitor(base jsonVisitor, fn func(delegate jsonVisitor, items []pogo.Parsed) jsonValue) jsonVisitor {
	return &jsonLambdaVisitor{
		base:           base,
		visitValueFunc: fn,
	}
}

func (v *jsonLambdaVisitor) visitValue(delegate jsonVisitor, items []pogo.Parsed) jsonValue {
	if v.visitValueFunc != nil {
		return v.visitValueFunc(delegate, items)
	}

	return v.base.visitValue(delegate, items)
}

// isValue determines if p is a Value production
func isValue(p pogo.Parsed) (pogo.Production, bool) {
	if prod, ok := p.(pogo.Production); ok {
		if prod.Ident == "Value" {
			return prod, ok
		}
	}
	return pogo.Production{}, false
}

// allValueChildren finds all Value productions in the given list of items, and returns their children as one list
func allValueChildren(v jsonVisitor, items []pogo.Parsed) []pogo.Parsed {
	result := make([]pogo.Parsed, 0)
	for _, p := range items {
		if prod, ok := isValue(p); ok {
			result = append(result, prod.Children...)
		}
	}
	return result
}

// accept interprets p as a production and accepts it
func accept(v jsonVisitor, p pogo.Parsed) interface{} {
	prod := p.(pogo.Production)
	switch prod.Ident {
	case "IntLiteral":
		return acceptIntLiteral(v, p)
	case "StringLiteral":
		return acceptStringLiteral(v, p)
	case "BooleanLiteral":
		return acceptBooleanLiteral(v, p)
	case "List":
		return acceptList(v, p)
	case "Dict":
		return acceptDict(v, p)
	case "Field":
		return acceptField(v, p)
	case "Value":
		return acceptValue(v, p)
	default:
		panic("unknown production")
	}
}

// acceptItem interprets p as a pogo.Item
func acceptItem(v jsonVisitor, p pogo.Parsed) pogo.Item {
	if item, ok := p.(pogo.Item); ok {
		return item
	}

	panic("expected Item")
}
